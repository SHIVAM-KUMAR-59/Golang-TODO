# ğŸš€ Full-Stack TODO Application with Modern Go Architecture

What started as a simple TODO app evolved into a **comprehensive exploration of modern backend and frontend technologies**. This project served as my deep dive into industry-standard tools, architectural patterns, and the seamless integration between Go backends and Next.js frontends.

## ğŸ¯ Why This Project Matters

While TODO apps might seem trivial, this implementation goes far beyond basic CRUD operations. It demonstrates:

- **Production-ready architecture** with clean separation of concerns
- **Type-safe communication** between frontend and backend
- **Modern tooling integration** that scales with real-world applications
- **Full-stack expertise** spanning Go microservices to React components

## ğŸ› ï¸ Technology Deep Dive

### Backend Powerhouse (Go)

- **ğŸ”Œ gRPC/ConnectRPC**: Learned how modern APIs can be both performant and developer-friendly
- **ğŸ“‹ Protobuf**: Mastered schema-first development and cross-language compatibility
- **ğŸ—ƒï¸ SQLC**: Experienced the power of compile-time SQL validation and type generation
- **ğŸ”„ Goose**: Implemented database versioning and migration strategies
- **ğŸ—ï¸ Clean Architecture**: Applied domain-driven design principles for maintainable code

### Frontend Innovation (Next.js)

- **ğŸŒ ConnectRPC Integration**: Bridged the gap between gRPC services and modern web applications
- **âš¡ Type-Safe APIs**: Leveraged generated TypeScript clients for seamless frontend-backend communication
- **ğŸ¨ Modern React Patterns**: Implemented hooks, context, and server components effectively

## ğŸ“ Backend Architecture

```bash
server/
â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ api/                            # gRPC API layer for handling requests
â”‚   â”‚   â”œâ”€â”€ grpcapi.go                  # Implementation of gRPC handlers
â”‚   â”‚   â””â”€â”€ server.go                   # gRPC server setup and routing
â”‚   â”œâ”€â”€ assert/
â”‚   â”‚   â””â”€â”€ assert.go                   # Utility functions for assertions in tests
â”‚   â”œâ”€â”€ errors/
â”‚   â”‚   â””â”€â”€ errors.go                   # Custom error definitions and helpers
â”‚   â”œâ”€â”€ logger/
â”‚   â”‚   â””â”€â”€ loger.go                    # Logging setup and helpers
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ pb/                         # Generated protobuf and gRPC code
â”‚   â”‚   â”‚   â”œâ”€â”€ pbconnect/              # Generated ConnectRPC client/server code
â”‚   â”‚   â”‚   â”œâ”€â”€ user.connect.go         # ConnectRPC Go code for User service
â”‚   â”‚   â”‚   â”œâ”€â”€ user_grpc.pb.go         # gRPC Go code for User service
â”‚   â”‚   â”‚   â””â”€â”€ user.pb.go              # Core Go protobuf types for User service
â”‚   â”‚   â””â”€â”€ user.proto                  # Protobuf definition for User service
â”‚
â”œâ”€â”€ service/                            # Business logic and domain services
â”‚   â”œâ”€â”€ internal/
â”‚   â”‚   â”œâ”€â”€ repository/                 # Data access layer abstractions
â”‚   â”‚   â”‚   â”œâ”€â”€ task/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ mapper.go           # Mapper for mapping DB object to entity
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ taskRepository.go   # Task repository with DB queries
â”‚   â”‚   â”‚   â””â”€â”€ user/
â”‚   â”‚   â”‚       â””â”€â”€ userRepository.go   # User repository with DB queries
â”‚   â”‚   â”œâ”€â”€ module.go                   # Dependency injection setup for internal services
â”‚   â”‚   â””â”€â”€ types.go                    # Shared internal types for repositories
â”‚   â”œâ”€â”€ task/                           # Folder for task service
â”‚   â”‚   â”œâ”€â”€ task.go                     # Buisness logic for task
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ entity/
â”‚   â”‚   â”‚   â”œâ”€â”€ task.go                 # Domain entity definition for Task
â”‚   â”‚   â”‚   â””â”€â”€ user.go                 # Domain entity definition for User
â”‚   â”œâ”€â”€ user/                           # Folder for user service
â”‚   â”‚   â”œâ”€â”€ service.go                  # Buisness logic for user
â”‚   â”œâ”€â”€ service.go                      # Business logic service definitions
â”‚   â””â”€â”€ module.go                       # Dependency injection for services
â”‚
â”œâ”€â”€ config/
â”‚   â””â”€â”€ config.go                       # Application configuration loading
â”‚
â”œâ”€â”€ infra/
â”‚   â””â”€â”€ database/
â”‚       â””â”€â”€ postgres/
â”‚           â”œâ”€â”€ gen/                    # Generated code from SQLC
â”‚           â”‚   â”œâ”€â”€ db.go               # SQLC database interfaces
â”‚           â”‚   â”œâ”€â”€ models.go           # Models generated by SQLC
â”‚           â”‚   â”œâ”€â”€ task.sql.go         # Go code for task SQL queries
â”‚           â”‚   â””â”€â”€ user.sql.go         # Go code for user SQL queries
â”‚           â”œâ”€â”€ migrations/             # SQL migrations for Postgres
â”‚           â”‚   â””â”€â”€ 0001_tables.sql     # Migration script to create tables
â”‚           â”‚   â””â”€â”€ migrate.go          # Migration code to run when server starts
â”‚           â”œâ”€â”€ queries/                # Raw SQL query files for SQLC
â”‚           â”‚   â”œâ”€â”€ task.sql            # SQL queries for tasks
â”‚           â”‚   â””â”€â”€ user.sql            # SQL queries for users
â”‚           â””â”€â”€ connection.go           # Postgres connection setup
â”‚
â”œâ”€â”€ buf.gen.yaml                        # Buf code generation configuration
â”œâ”€â”€ buf.yaml                            # Buf workspace config
â”œâ”€â”€ config.yaml                         # Configuration in YAML format
â”œâ”€â”€ go.mod                              # Go module definitions
â”œâ”€â”€ go.sum                              # Go module dependency checksums
â”œâ”€â”€ main.go                             # Main application entry point
â”œâ”€â”€ makefile                            # Makefile for common tasks
â””â”€â”€ sqlc.yaml                           # SQLC configuration file
```

## Architecture Overview

This project follows **Clean Architecture** principles with clear separation of concerns:

### Layers

1. **Application Layer** (`application/`)

   - **API**: gRPC handlers and server setup
   - **Models**: Generated protobuf and ConnectRPC code
   - **Infrastructure**: Logging, error handling, assertions

2. **Service Layer** (`service/`)

   - **Business Logic**: Core domain services for Task and User operations
   - **Entities**: Domain models representing business concepts
   - **Repository Interfaces**: Abstractions for data access

3. **Infrastructure Layer** (`infra/`)
   - **Database**: PostgreSQL connection and SQLC generated code
   - **Migrations**: SQL schema evolution
   - **Configuration**: YAML-based app configuration

## ğŸŒŸ Key Learning Outcomes

### Backend Mastery

- **Schema-First Development**: Used protobuf to define contracts before implementation
- **Type Safety at Scale**: Leveraged SQLC to eliminate runtime SQL errors
- **Clean Architecture**: Implemented proper separation between business logic and infrastructure
- **Modern Go Patterns**: Applied dependency injection, interfaces, and modular design

### Frontend Innovation

- **ConnectRPC in Next.js**: Successfully integrated gRPC-style APIs with modern React applications
- **Type-Safe Frontend**: Generated TypeScript clients from protobuf schemas for end-to-end type safety
- **Modern React Architecture**: Implemented server components, hooks, and context patterns effectively
- **Seamless API Integration**: Created smooth data flow between frontend components and backend services

### DevOps & Tooling

- **Database Migrations**: Managed schema evolution with Goose
- **Code Generation**: Automated repetitive code with protobuf and SQLC
- **Build Automation**: Created efficient development workflows with Make
- **Configuration Management**: Implemented environment-aware application setup

## ğŸ”„ The Full-Stack Experience

This project provided hands-on experience with the complete development lifecycle:

1. **Schema Design**: Started with protobuf definitions for API contracts
2. **Backend Development**: Built robust Go services with clean architecture
3. **Database Design**: Created efficient PostgreSQL schemas with proper migrations
4. **Frontend Integration**: Connected Next.js applications to gRPC services via ConnectRPC
5. **Type Safety**: Maintained end-to-end type safety from database to UI components
6. **Testing & Validation**: Ensured reliability through comprehensive testing strategies

## ğŸ’¡ Why This Approach Matters

This isn't just another TODO appâ€”it's a **miniature representation of enterprise-grade software development**. The patterns, tools, and architectural decisions mirror those used in production systems at scale, making it an invaluable learning experience for modern full-stack development.

The combination of Go's performance and safety with Next.js's developer experience, all connected through type-safe APIs, represents the future of web application development.
